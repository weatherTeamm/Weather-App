// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AuthState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthStateCopyWith<$Res> {
  factory $AuthStateCopyWith(AuthState value, $Res Function(AuthState) then) =
      _$AuthStateCopyWithImpl<$Res, AuthState>;
}

/// @nodoc
class _$AuthStateCopyWithImpl<$Res, $Val extends AuthState>
    implements $AuthStateCopyWith<$Res> {
  _$AuthStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'AuthState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements AuthState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingSignInImplCopyWith<$Res> {
  factory _$$LoadingSignInImplCopyWith(
          _$LoadingSignInImpl value, $Res Function(_$LoadingSignInImpl) then) =
      __$$LoadingSignInImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingSignInImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$LoadingSignInImpl>
    implements _$$LoadingSignInImplCopyWith<$Res> {
  __$$LoadingSignInImplCopyWithImpl(
      _$LoadingSignInImpl _value, $Res Function(_$LoadingSignInImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingSignInImpl implements LoadingSignIn {
  const _$LoadingSignInImpl();

  @override
  String toString() {
    return 'AuthState.loadingSignIn()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingSignInImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return loadingSignIn();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return loadingSignIn?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (loadingSignIn != null) {
      return loadingSignIn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return loadingSignIn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return loadingSignIn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (loadingSignIn != null) {
      return loadingSignIn(this);
    }
    return orElse();
  }
}

abstract class LoadingSignIn implements AuthState {
  const factory LoadingSignIn() = _$LoadingSignInImpl;
}

/// @nodoc
abstract class _$$SuccessSignInImplCopyWith<$Res> {
  factory _$$SuccessSignInImplCopyWith(
          _$SuccessSignInImpl value, $Res Function(_$SuccessSignInImpl) then) =
      __$$SuccessSignInImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserModel userProfile});
}

/// @nodoc
class __$$SuccessSignInImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$SuccessSignInImpl>
    implements _$$SuccessSignInImplCopyWith<$Res> {
  __$$SuccessSignInImplCopyWithImpl(
      _$SuccessSignInImpl _value, $Res Function(_$SuccessSignInImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userProfile = null,
  }) {
    return _then(_$SuccessSignInImpl(
      null == userProfile
          ? _value.userProfile
          : userProfile // ignore: cast_nullable_to_non_nullable
              as UserModel,
    ));
  }
}

/// @nodoc

class _$SuccessSignInImpl implements SuccessSignIn {
  const _$SuccessSignInImpl(this.userProfile);

  @override
  final UserModel userProfile;

  @override
  String toString() {
    return 'AuthState.successSignIn(userProfile: $userProfile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessSignInImpl &&
            (identical(other.userProfile, userProfile) ||
                other.userProfile == userProfile));
  }

  @override
  int get hashCode => Object.hash(runtimeType, userProfile);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessSignInImplCopyWith<_$SuccessSignInImpl> get copyWith =>
      __$$SuccessSignInImplCopyWithImpl<_$SuccessSignInImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return successSignIn(userProfile);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return successSignIn?.call(userProfile);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (successSignIn != null) {
      return successSignIn(userProfile);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return successSignIn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return successSignIn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (successSignIn != null) {
      return successSignIn(this);
    }
    return orElse();
  }
}

abstract class SuccessSignIn implements AuthState {
  const factory SuccessSignIn(final UserModel userProfile) =
      _$SuccessSignInImpl;

  UserModel get userProfile;

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SuccessSignInImplCopyWith<_$SuccessSignInImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FailureSignInImplCopyWith<$Res> {
  factory _$$FailureSignInImplCopyWith(
          _$FailureSignInImpl value, $Res Function(_$FailureSignInImpl) then) =
      __$$FailureSignInImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$FailureSignInImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$FailureSignInImpl>
    implements _$$FailureSignInImplCopyWith<$Res> {
  __$$FailureSignInImplCopyWithImpl(
      _$FailureSignInImpl _value, $Res Function(_$FailureSignInImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$FailureSignInImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FailureSignInImpl implements FailureSignIn {
  const _$FailureSignInImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'AuthState.failureSignIn(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FailureSignInImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FailureSignInImplCopyWith<_$FailureSignInImpl> get copyWith =>
      __$$FailureSignInImplCopyWithImpl<_$FailureSignInImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return failureSignIn(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return failureSignIn?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (failureSignIn != null) {
      return failureSignIn(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return failureSignIn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return failureSignIn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (failureSignIn != null) {
      return failureSignIn(this);
    }
    return orElse();
  }
}

abstract class FailureSignIn implements AuthState {
  const factory FailureSignIn({required final String message}) =
      _$FailureSignInImpl;

  String get message;

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FailureSignInImplCopyWith<_$FailureSignInImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadingRegisterImplCopyWith<$Res> {
  factory _$$LoadingRegisterImplCopyWith(_$LoadingRegisterImpl value,
          $Res Function(_$LoadingRegisterImpl) then) =
      __$$LoadingRegisterImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingRegisterImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$LoadingRegisterImpl>
    implements _$$LoadingRegisterImplCopyWith<$Res> {
  __$$LoadingRegisterImplCopyWithImpl(
      _$LoadingRegisterImpl _value, $Res Function(_$LoadingRegisterImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingRegisterImpl implements LoadingRegister {
  const _$LoadingRegisterImpl();

  @override
  String toString() {
    return 'AuthState.loadingRegister()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingRegisterImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return loadingRegister();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return loadingRegister?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (loadingRegister != null) {
      return loadingRegister();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return loadingRegister(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return loadingRegister?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (loadingRegister != null) {
      return loadingRegister(this);
    }
    return orElse();
  }
}

abstract class LoadingRegister implements AuthState {
  const factory LoadingRegister() = _$LoadingRegisterImpl;
}

/// @nodoc
abstract class _$$SuccessRegisterImplCopyWith<$Res> {
  factory _$$SuccessRegisterImplCopyWith(_$SuccessRegisterImpl value,
          $Res Function(_$SuccessRegisterImpl) then) =
      __$$SuccessRegisterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({User user});
}

/// @nodoc
class __$$SuccessRegisterImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$SuccessRegisterImpl>
    implements _$$SuccessRegisterImplCopyWith<$Res> {
  __$$SuccessRegisterImplCopyWithImpl(
      _$SuccessRegisterImpl _value, $Res Function(_$SuccessRegisterImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = null,
  }) {
    return _then(_$SuccessRegisterImpl(
      null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
    ));
  }
}

/// @nodoc

class _$SuccessRegisterImpl implements SuccessRegister {
  const _$SuccessRegisterImpl(this.user);

  @override
  final User user;

  @override
  String toString() {
    return 'AuthState.successRegister(user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessRegisterImpl &&
            (identical(other.user, user) || other.user == user));
  }

  @override
  int get hashCode => Object.hash(runtimeType, user);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessRegisterImplCopyWith<_$SuccessRegisterImpl> get copyWith =>
      __$$SuccessRegisterImplCopyWithImpl<_$SuccessRegisterImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return successRegister(user);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return successRegister?.call(user);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (successRegister != null) {
      return successRegister(user);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return successRegister(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return successRegister?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (successRegister != null) {
      return successRegister(this);
    }
    return orElse();
  }
}

abstract class SuccessRegister implements AuthState {
  const factory SuccessRegister(final User user) = _$SuccessRegisterImpl;

  User get user;

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SuccessRegisterImplCopyWith<_$SuccessRegisterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FailureRegisterImplCopyWith<$Res> {
  factory _$$FailureRegisterImplCopyWith(_$FailureRegisterImpl value,
          $Res Function(_$FailureRegisterImpl) then) =
      __$$FailureRegisterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$FailureRegisterImplCopyWithImpl<$Res>
    extends _$AuthStateCopyWithImpl<$Res, _$FailureRegisterImpl>
    implements _$$FailureRegisterImplCopyWith<$Res> {
  __$$FailureRegisterImplCopyWithImpl(
      _$FailureRegisterImpl _value, $Res Function(_$FailureRegisterImpl) _then)
      : super(_value, _then);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$FailureRegisterImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FailureRegisterImpl implements FailureRegister {
  const _$FailureRegisterImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'AuthState.failureRegister(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FailureRegisterImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FailureRegisterImplCopyWith<_$FailureRegisterImpl> get copyWith =>
      __$$FailureRegisterImplCopyWithImpl<_$FailureRegisterImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadingSignIn,
    required TResult Function(UserModel userProfile) successSignIn,
    required TResult Function(String message) failureSignIn,
    required TResult Function() loadingRegister,
    required TResult Function(User user) successRegister,
    required TResult Function(String message) failureRegister,
  }) {
    return failureRegister(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadingSignIn,
    TResult? Function(UserModel userProfile)? successSignIn,
    TResult? Function(String message)? failureSignIn,
    TResult? Function()? loadingRegister,
    TResult? Function(User user)? successRegister,
    TResult? Function(String message)? failureRegister,
  }) {
    return failureRegister?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadingSignIn,
    TResult Function(UserModel userProfile)? successSignIn,
    TResult Function(String message)? failureSignIn,
    TResult Function()? loadingRegister,
    TResult Function(User user)? successRegister,
    TResult Function(String message)? failureRegister,
    required TResult orElse(),
  }) {
    if (failureRegister != null) {
      return failureRegister(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(LoadingSignIn value) loadingSignIn,
    required TResult Function(SuccessSignIn value) successSignIn,
    required TResult Function(FailureSignIn value) failureSignIn,
    required TResult Function(LoadingRegister value) loadingRegister,
    required TResult Function(SuccessRegister value) successRegister,
    required TResult Function(FailureRegister value) failureRegister,
  }) {
    return failureRegister(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(LoadingSignIn value)? loadingSignIn,
    TResult? Function(SuccessSignIn value)? successSignIn,
    TResult? Function(FailureSignIn value)? failureSignIn,
    TResult? Function(LoadingRegister value)? loadingRegister,
    TResult? Function(SuccessRegister value)? successRegister,
    TResult? Function(FailureRegister value)? failureRegister,
  }) {
    return failureRegister?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(LoadingSignIn value)? loadingSignIn,
    TResult Function(SuccessSignIn value)? successSignIn,
    TResult Function(FailureSignIn value)? failureSignIn,
    TResult Function(LoadingRegister value)? loadingRegister,
    TResult Function(SuccessRegister value)? successRegister,
    TResult Function(FailureRegister value)? failureRegister,
    required TResult orElse(),
  }) {
    if (failureRegister != null) {
      return failureRegister(this);
    }
    return orElse();
  }
}

abstract class FailureRegister implements AuthState {
  const factory FailureRegister({required final String message}) =
      _$FailureRegisterImpl;

  String get message;

  /// Create a copy of AuthState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FailureRegisterImplCopyWith<_$FailureRegisterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
